# NetrunnerOS: System Design Document

## Core Concept
A hacker's interface that serves as both the game's menu system and a core gameplay mechanic. The interface itself is part of the puzzle - learning to manipulate windows, save states, and combine tools is key to solving increasingly complex challenges.

## System Components

### 1. Core OS Interface
- Simple ASCII-art boot sequence
- Basic command line interface
- Filesystem navigation
- Process/program list
- Status monitors
- Placeholder "dev art" aesthetic (designed to be replaceable)

### 2. Scene Management System
Core functionality required for both gameplay and puzzle development:

#### Encounter Management
- Pure game logic in IEncounter implementations
- Scene managers for UI/presentation
- State persistence between encounters
- Resource management and validation

#### Scene Types
- Card Game Scene (hand viewer, play area)
- Resource Market Scene
- Process Viewer Scene
- Memory Bank Scene
- System Monitor Scene

#### Window System
- Drag and drop support
- Window stacking and focus
- CRT and terminal effects
- State inspection tools

### 3. Puzzle Development Framework
Tools that double as in-game "hacking programs":

#### Challenge Builder
- Encounter configuration interface
- Win condition editor
- Initial state configuration
- AI behavior configuration

#### Multi-Encounter Tools
- State capture system
- Resource sharing management
- Encounter chain editor
- Validation tools

## Development Phases

### Phase 1: Core Systems (Current Focus)
1. Scene Manager System
   - Clean separation of game logic and UI
   - Scene manager base classes
   - Resource validation system
   - Multi-encounter support

2. Card Game Implementation
   - Pure game logic layer
   - UI/presentation layer
   - Resource management
   - Basic encounter types

3. Window System Polish
   - Window dragging and stacking
   - Focus management
   - Terminal effects
   - UI consistency

[Rest of phases remain largely the same, just updated terminology from Scenario->Encounter]

## Technical Considerations

### Scene Management
```csharp
public partial class EncounterScene : Node
{
    protected IEncounter Encounter { get; }
    void Initialize(IEncounter encounter);
    protected virtual void OnEncounterStateChanged(Dictionary<string, object> state);
}

public class CardEncounterScene : EncounterScene
{
    private CardTerminalWindow _handWindow;
    private CardTerminalWindow _tableWindow;
    protected override void OnEncounterStateChanged(Dictionary<string, object> state);
}
```

### Game Logic
```csharp
public interface IEncounter
{
    string Id { get; }
    string Type { get; }
    Dictionary<string, float> ResourceRequirements { get; }
    void Initialize(Dictionary<string, object> initialState);
    Dictionary<string, object> GetState();
}
```

### State Persistence
```csharp
public class EncounterManager : Node
{
    private Dictionary<string, (IEncounter encounter, EncounterScene scene)> _activeEncounters;
    public bool StartEncounter(IEncounter encounter);
    public IEncounter GetEncounter(string encounterId);
}
```

## Implementation Priority

### Immediate Tasks
1. Complete scene manager system
2. Resource validation and management
3. Multi-encounter support
4. CRT and terminal effects

### Near-Term Goals
1. Extended encounter types
2. Resource market implementation
3. Puzzle creation tools
4. State persistence system

### Future Considerations
1. AI encounter generation
2. Advanced window interactions
3. Complex state manipulation
4. Achievement/progression system

## Notes
- Focus on clean separation of concerns
- Design systems to be AI-friendly
- Keep ASCII art simple but thematic
- Plan for future asset replacement
- Document all window interaction mechanics
- Consider achievement system tied to interface discovery