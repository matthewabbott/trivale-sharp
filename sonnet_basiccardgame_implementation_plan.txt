# Card Game Implementation Plan for AI Agent

## Overview
This document outlines a structured implementation plan for adding a playable card game encounter (contract whist variant) that integrates with the existing main menu and memory slot system. The plan is specifically formatted for an AI coding agent to follow systematically.

## Requirements Summary
- Contract whist mechanics with 5 cards per player
- 1 human player + 3 AI opponents
- Simple "play in order" AI
- Integration with memory slot system
- Clean process lifecycle management
- Simple UI with future ASCII art in mind

## Implementation Structure

### Phase 1: Card Game Process and Scene Setup

#### Task 1.1: Create CardGameProcess Class
```csharp
// Create new class in src/OS/MainMenu/Processes/CardGameProcess.cs
public class CardGameProcess : BaseProcess
{
    public override string Type => "CardGame";
    
    public override Dictionary<string, float> ResourceRequirements => new Dictionary<string, float>
    {
        ["MEM"] = 0.3f,
        ["CPU"] = 0.2f
    };
    
    // Game configuration state variables
    private int _numPlayers = 4;
    private int _handSize = 5;
    private int _targetTricks = 2;
    
    public CardGameProcess(string id) : base(id) { }
    
    protected override void OnInitialize() 
    {
        // Initialize game state
    }
    
    protected override void OnUpdate(float delta)
    {
        // Handle process updates
    }
    
    protected override void OnCleanup()
    {
        // Clean up resources
    }
}
```

#### Task 1.2: Update CardGameScene Class
```csharp
// Update src/OS/MainMenu/CardGameScene.cs
public partial class CardGameScene : Control, IOrchestratableScene
{
    private GameState _gameState;
    private VBoxContainer _mainContainer;
    private HBoxContainer _playerHandContainer;
    private HBoxContainer _trickArea;
    private Label _statusLabel;
    private Label _trumpLabel;
    private Label _scoreLabel;
    private SceneOrchestrator _orchestrator;
    
    public void SetOrchestrator(SceneOrchestrator orchestrator)
    {
        _orchestrator = orchestrator;
    }
    
    public string GetProcessId()
    {
        return HasMeta("ProcessId") ? (string)GetMeta("ProcessId") : null;
    }
    
    public override void _Ready()
    {
        SetupUI();
        InitializeGame();
        ConnectSignals();
    }
    
    private void SetupUI()
    {
        // Create UI layout with containers for:
        // - Player hand
        // - Current trick
        // - Game status
        // - Controls
    }
    
    private void InitializeGame()
    {
        // Initialize game state and deal cards
    }
    
    private void ConnectSignals()
    {
        // Connect to game events
    }
    
    // Implement additional methods for game interaction
}
```

#### Task 1.3: Add Menu Integration
```csharp
// Update MainMenuScene.cs to add card game option
// Add to the CreateMenuButton method or equivalent:
_cardGameButton = CreateStyledButton("CARD GAME", Colors.Green);
_cardGameButton.Pressed += () => EmitSignal(SignalName.MenuOptionSelected, 
    "res://Scenes/MainMenu/CardGameScene.tscn", "CardGame");
```

### Phase 2: Game Logic Implementation

#### Task 2.1: Implement Game Configuration
```csharp
// Use existing GameConfiguration class or create new one:
public class GameConfiguration
{
    public int NumPlayers { get; set; } = 4;
    public int HandSize { get; set; } = 5;
    public int RequiredTricks { get; set; } = 2;
    public Suit TrumpSuit { get; set; } = Suit.None; // Randomly determined
    
    public static GameConfiguration Default => new GameConfiguration();
}

// Add to CardGameProcess.OnInitialize:
void InitializeGameConfiguration()
{
    var config = new GameConfiguration
    {
        NumPlayers = _numPlayers,
        HandSize = _handSize,
        RequiredTricks = _targetTricks,
        TrumpSuit = GetRandomSuit()
    };
    
    State["gameConfig"] = config;
}
```

#### Task 2.2: Implement Core Game Loop
```csharp
// In CardGameScene.cs:
private void InitializeGame()
{
    _gameState = new GameState();
    AddChild(_gameState);
    
    // Get configuration from process
    var processId = GetProcessId();
    var process = _orchestrator.GetProcessManager().GetProcess(processId);
    var config = process?.GetState().TryGetValue("gameConfig", out var configObj) 
        ? configObj as GameConfiguration 
        : GameConfiguration.Default;
    
    // Initialize game with configuration
    _gameState.InitializeGame(
        EncounterType.SecuredSystem,
        config.NumPlayers,
        config.HandSize,
        config.RequiredTricks);
    
    // Connect to game events
    _gameState.GameStateChanged += UpdateDisplay;
    _gameState.TrickCompleted += OnTrickCompleted;
    _gameState.GameOver += OnGameOver;
    
    UpdateDisplay();
}

private void UpdateDisplay()
{
    // Update UI elements based on game state:
    // - Player hand
    // - Current trick
    // - Trump suit
    // - Scores/tricks
    // - Status messages
}
```

#### Task 2.3: Implement AI Turns and Card Playing
```csharp
// In CardGameScene.cs:
private void OnPlayerCardSelected(Card card)
{
    if (_gameState.IsGameOver) return;
    
    if (_gameState.PlayCard(0, card))
    {
        // Card played successfully, now handle AI turns
        PlayAITurns();
    }
}

private void PlayAITurns()
{
    _gameState.PlayAITurns();
    UpdateDisplay();
}
```

### Phase 3: UI and Interaction

#### Task 3.1: Implement Card Display and Selection
```csharp
// In CardGameScene.cs:
private void UpdatePlayerHand()
{
    _playerHandContainer.QueueFreeChildren();
    
    var hand = _gameState.GetHand(0);
    foreach (var card in hand)
    {
        var cardButton = CreateCardButton(card);
        _playerHandContainer.AddChild(cardButton);
    }
}

private Button CreateCardButton(Card card)
{
    var button = new Button
    {
        Text = GetCardDisplayText(card),
        Disabled = !_gameState.IsValidPlay(0, card)
    };
    
    // Style button based on suit
    StyleCardButton(button, card.Suit);
    
    button.Pressed += () => OnPlayerCardSelected(card);
    
    return button;
}

private string GetCardDisplayText(Card card)
{
    // Simple text representation, to be replaced with ASCII art later
    return $"{card.GetValueName()} of {card.GetSuitName()}";
}
```

#### Task 3.2: Implement Game State Display
```csharp
// In CardGameScene.cs:
private void UpdateGameStatus()
{
    _trumpLabel.Text = $"Trump: {_gameState.GetTrumpSuit()}";
    _scoreLabel.Text = $"Your tricks: {_gameState.GetScore(0)}/{_gameState.GetRequiredTricks(0)}";
    
    var currentPlayer = _gameState.GetCurrentPlayer();
    var leadSuit = _gameState.GetLeadSuit();
    
    _statusLabel.Text = _gameState.IsGameOver
        ? $"Game Over! {(_gameState.GetWinner() == 0 ? "You won!" : "You lost!")}"
        : $"Current player: {(currentPlayer == 0 ? "You" : $"AI {currentPlayer}")}";
        
    if (leadSuit != Suit.None)
    {
        _statusLabel.Text += $"\nLead suit: {leadSuit}";
    }
}

private void UpdateTrickArea()
{
    _trickArea.QueueFreeChildren();
    
    foreach (var card in _gameState.GetTableCards())
    {
        var cardLabel = new Label
        {
            Text = GetCardDisplayText(card),
            SizeFlagsHorizontal = SizeFlags.Expand
        };
        _trickArea.AddChild(cardLabel);
    }
}
```

#### Task 3.3: Implement Game Flow Controls
```csharp
// In CardGameScene.cs:
private void OnTrickCompleted(int winner)
{
    // Show trick winner announcement
    _statusLabel.Text = $"Player {winner} won the trick!";
    
    // Update display after a short delay
    GetTree().CreateTimer(1.0).Timeout += UpdateDisplay;
}

private void OnGameOver(int winner)
{
    // Show game result
    _statusLabel.Text = winner == 0
        ? "You won the game!"
        : $"Player {winner} won. You lost!";
    
    // Show restart button
    _restartButton.Visible = true;
}

private void OnRestartPressed()
{
    // Clean up old game state
    if (_gameState != null)
    {
        _gameState.QueueFree();
    }
    
    // Initialize new game
    InitializeGame();
    
    // Hide restart button
    _restartButton.Visible = false;
}

private void OnReturnToMenuPressed()
{
    if (_orchestrator != null)
    {
        // Get process ID from metadata
        string processId = GetProcessId();
        
        // Request scene unload
        _orchestrator.RequestSceneUnload(processId);
    }
}
```

### Phase 4: Testing and Refinement

#### Task 4.1: Validate Game Rules
```csharp
// Add testing code or manual test cases:
void TestGameRules()
{
    // Test cases for:
    // - Card playing validation
    // - Trick winning determination
    // - Trump handling
    // - Game outcome calculation
}
```

#### Task 4.2: Verify Process Lifecycle
```csharp
// Add cleanup code to CardGameScene:
public override void _ExitTree()
{
    // Disconnect signals
    if (_gameState != null)
    {
        _gameState.GameStateChanged -= UpdateDisplay;
        _gameState.TrickCompleted -= OnTrickCompleted;
        _gameState.GameOver -= OnGameOver;
    }
    
    // Clean up resources
    base._ExitTree();
}
```

## Detailed Task Flow for Implementation

1. **Create CardGameProcess Class**
   - Create new file in src/OS/MainMenu/Processes
   - Implement BaseProcess inheritance
   - Define resource requirements
   - Set up game configuration state

2. **Update CardGameScene**
   - Update existing scene or create new one
   - Implement UI layout with placeholders
   - Add IOrchestratableScene implementation
   - Create setup for game state initialization

3. **Connect to Main Menu**
   - Add menu entry in MainMenuScene
   - Configure scene path and process type
   - Test basic navigation

4. **Implement Game Initialization**
   - Set up GameConfiguration object
   - Add initialization from process state
   - Implement card dealing and setup

5. **Create UI for Player Hand**
   - Add container for cards
   - Create card representation
   - Implement selection mechanism
   - Add visual feedback for valid/invalid plays

6. **Implement Game State Display**
   - Create labels for game status
   - Add trick area visualization
   - Show trump and lead suit indicators
   - Display score and target tracking

7. **Create AI Logic**
   - Use existing AIController if possible
   - Implement simple card selection
   - Ensure rule compliance

8. **Implement Turn Flow**
   - Handle player card selection
   - Process AI turns
   - Update UI after each play
   - Show trick resolution

9. **Add Game Completion Logic**
   - Determine win/loss conditions
   - Show game outcome
   - Add restart functionality
   - Provide return to menu option

10. **Test and Debug**
    - Verify rule implementation
    - Check slot integration
    - Test process lifecycle
    - Fix identified issues

## Future-Proofing Notes

1. **Shared Deck System**
   - Keep card generation separate from game initialization
   - Consider future factory method for card creation
   - Design with global deck object in mind

2. **AI Behavior Extensions**
   - Use strategy pattern for AI decision making
   - Allow for behavior attachment to cards
   - Keep AI implementation flexible

3. **UI Evolution**
   - Separate display logic from game logic
   - Use methods that can be updated for ASCII art
   - Keep styling separate from structure

4. **Multi-Encounter Support**
   - Design state tracking with serialization in mind
   - Use ProcessSlotRegistry for future cross-slot references
   - Keep resource boundaries clear