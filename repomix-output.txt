This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T07:06:57.243Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitattributes
.gitignore
icon.svg
icon.svg.import
project.godot
readme.md
src/Cards/Card.cs
src/Game/GameManager.cs
src/Game/GameState.cs
src/Terminal/Terminal.cs

================================================================
Files
================================================================

================
File: .gitattributes
================
# Normalize EOL for all files that Git considers text files.
* text=auto eol=lf

================
File: .gitignore
================
# Godot 4+ specific ignores
.godot/
/android/
_*.txt

================
File: icon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><rect width="124" height="124" x="2" y="2" fill="#363d52" stroke="#212532" stroke-width="4" rx="14"/><g fill="#fff" transform="translate(12.322 12.322)scale(.101)"><path d="M105 673v33q407 354 814 0v-33z"/><path fill="#478cbf" d="m105 673 152 14q12 1 15 14l4 67 132 10 8-61q2-11 15-15h162q13 4 15 15l8 61 132-10 4-67q3-13 15-14l152-14V427q30-39 56-81-35-59-83-108-43 20-82 47-40-37-88-64 7-51 8-102-59-28-123-42-26 43-46 89-49-7-98 0-20-46-46-89-64 14-123 42 1 51 8 102-48 27-88 64-39-27-82-47-48 49-83 108 26 42 56 81zm0 33v39c0 276 813 276 814 0v-39l-134 12-5 69q-2 10-14 13l-162 11q-12 0-16-11l-10-65H446l-10 65q-4 11-16 11l-162-11q-12-3-14-13l-5-69z"/><path d="M483 600c0 34 58 34 58 0v-86c0-34-58-34-58 0z"/><circle cx="725" cy="526" r="90"/><circle cx="299" cy="526" r="90"/></g><g fill="#414042" transform="translate(12.322 12.322)scale(.101)"><circle cx="307" cy="532" r="60"/><circle cx="717" cy="532" r="60"/></g></svg>

================
File: icon.svg.import
================
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://djffc8eedob21"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false

================
File: project.godot
================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Trivale"
config/features=PackedStringArray("4.3", "Forward Plus")
config/icon="res://icon.svg"

[dotnet]

project/assembly_name="Trivale"

================
File: readme.md
================
## File Structure

trivale-sharp/
├── .godot/          # Godot cache and settings (git ignored)
├── project.godot    # Godot project file
├── Trivale.sln     # C# solution file
├── Trivale.csproj  # C# project file
├── src/            # C# code
│   ├── Cards/      # Card system
│   ├── Terminal/   # Terminal UI system
│   ├── Game/       # Core game logic
│   └── Utils/      # Utilities and helpers
├── Assets/         # Game assets
│   ├── Fonts/
│   ├── Shaders/
│   └── Textures/
└── Scenes/         # Godot scenes
    ├── Main.tscn
    ├── Terminal.tscn
    └── Card.tscn

================
File: src/Cards/Card.cs
================
// src/Cards/Card.cs

using Godot;
using System;

namespace Trivale.Cards;

public enum Suit
{
    DataFlow,    // Hearts    - Information streams and memory
    Crypto,      // Diamonds  - Digital currency and resources
    Infra,       // Clubs     - System backbone and architecture
    Process,     // Spades    - Program execution and logic
    None,        // Used for special cases
    NoTrump      // Used for game state
}

public enum Value
{
    Two = 2,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,    // System access
    Queen,   // Admin privileges
    King,    // Root access
    Ace      // Master key
}

public enum AIBehavior
{
    None,           // No special behavior
    OrderedPlay,    // Plays in a specific order
    TrickTaker,     // Tries to win tricks
    TrickDodger    // Tries to avoid winning
}

public partial class Card : Node2D
{
    [Export]
    public Suit Suit { get; set; }
    
    [Export]
    public Value Value { get; set; }
    
    [Export]
    public int Owner { get; set; } = -1; // -1 means unowned
    
    [Export]
    public AIBehavior Behavior { get; set; } = AIBehavior.None;
    
    // For OrderedPlay behavior
    [Export]
    public int PlayOrder { get; set; } = -1;
    
    public string Id => $"{GetValueName().Substring(0, 1)}{GetSuitName().Substring(0, 1)}";
    
    private static readonly string[] ValueNames = 
    {
        "", "", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
        "Jack", "Queen", "King", "Ace"
    };
    
    private static readonly string[] SuitNames = 
    {
        "Data Flow", "Cryptocurrency", "Infrastructure", "Process Control", 
        "None", "No-Trump"
    };
    
    private static readonly string[] SuitSymbols =
    {
        "♥", "♦", "♣", "♠", "", ""
    };
    
    private ShaderMaterial _effectMaterial;
    private Area2D _clickArea;
    private Sprite2D _sprite;
    private Label _cardText;
    
    // Signals
    [Signal]
    public delegate void CardClickedEventHandler(Card card);
    
    public override void _Ready()
    {
        SetupVisuals();
        SetupInteraction();
        UpdateCardDisplay();
    }
    
    private void SetupVisuals()
    {
        _effectMaterial = new ShaderMaterial();
        
        _sprite = GetNode<Sprite2D>("Sprite2D");
        _cardText = new Label
        {
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center
        };
        AddChild(_cardText);
        
        // TODO: Load and set up suit-specific shader effects
        SetupSuitEffects();
    }
    
    private void SetupSuitEffects()
    {
        // Each suit gets its own visual effects
        switch (Suit)
        {
            case Suit.DataFlow:
                // Data stream particles, memory core glow
                break;
            case Suit.Crypto:
                // Market data overlays, transaction effects
                break;
            case Suit.Infra:
                // Blueprint grid, network lines
                break;
            case Suit.Process:
                // Command line overlay, execution visualization
                break;
        }
    }
    
    private void SetupInteraction()
    {
        _clickArea = new Area2D();
        AddChild(_clickArea);
        
        var collisionShape = new CollisionShape2D();
        var shape = new RectangleShape2D();
        shape.Size = new Vector2(200, 280); // Standard card size
        collisionShape.Shape = shape;
        _clickArea.AddChild(collisionShape);
        
        _clickArea.InputEvent += OnInputEvent;
    }
    
    public void UpdateCardDisplay()
    {
        if (_cardText != null)
        {
            _cardText.Text = GetDisplayText();
        }
    }
    
    private string GetDisplayText()
    {
        string baseText = $"{GetValueName()} of {GetSuitName()}";
        if (Behavior != AIBehavior.None)
        {
            baseText += $"\n[{Behavior}]";
            if (Behavior == AIBehavior.OrderedPlay && PlayOrder >= 0)
            {
                baseText += $" ({PlayOrder})";
            }
        }
        return baseText;
    }
    
    public string GetValueName() => ValueNames[(int)Value];
    public string GetSuitName() => SuitNames[(int)Suit];
    public string GetSuitSymbol() => SuitSymbols[(int)Suit];
    public string GetFullName() => $"{GetValueName()} of {GetSuitName()}";
    
    private void OnInputEvent(Node viewport, InputEvent @event, long shapeIdx)
    {
        if (@event is InputEventMouseButton mouseEvent && 
            mouseEvent.ButtonIndex == MouseButton.Left && 
            mouseEvent.Pressed)
        {
            EmitSignal(SignalName.CardClicked, this);
        }
    }
    
    public static int CompareCards(Card card1, Card card2, Suit trumpSuit)
    {
        if (card1.Suit == card2.Suit)
        {
            return ((int)card1.Value).CompareTo((int)card2.Value);
        }
        
        if (trumpSuit != Suit.None && trumpSuit != Suit.NoTrump)
        {
            if (card1.Suit == trumpSuit) return 1;
            if (card2.Suit == trumpSuit) return -1;
        }
        
        return 0;  // Different non-trump suits
    }
    
    public Card Duplicate()
    {
        var card = new Card
        {
            Suit = Suit,
            Value = Value,
            Owner = Owner,
            Behavior = Behavior,
            PlayOrder = PlayOrder
        };
        return card;
    }
}

================
File: src/Game/GameManager.cs
================
// src/Game/GameManager.cs

using Godot;
using System.Collections.Generic;
using Trivale.Cards;

namespace Trivale.Game;

public partial class GameManager : Node
{
    private List<Card> _deck = new();
    private List<List<Card>> _playerHands = new();
    private int _currentPlayer = 0;
    private int _numPlayers = 4;
    
    public override void _Ready()
    {
        InitializeGame();
    }
    
    private void InitializeGame()
    {
        CreateDeck();
        ShuffleDeck();
        DealCards();
    }
    
    private void CreateDeck()
    {
        foreach (Suit suit in System.Enum.GetValues(typeof(Suit)))
        {
            foreach (Value value in System.Enum.GetValues(typeof(Value)))
            {
                var card = new Card
                {
                    Suit = suit,
                    Value = value
                };
                _deck.Add(card);
            }
        }
    }
    
    private void ShuffleDeck()
    {
        var random = new System.Random();
        int n = _deck.Count;
        while (n > 1)
        {
            n--;
            int k = random.Next(n + 1);
            (_deck[k], _deck[n]) = (_deck[n], _deck[k]);
        }
    }
    
    private void DealCards()
    {
        _playerHands.Clear();
        for (int i = 0; i < _numPlayers; i++)
        {
            _playerHands.Add(new List<Card>());
        }
        
        int cardsPerPlayer = 13; // For a standard game
        for (int i = 0; i < cardsPerPlayer * _numPlayers; i++)
        {
            _playerHands[i % _numPlayers].Add(_deck[i]);
        }
    }
}

================
File: src/Game/GameState.cs
================
// src/Game/GameState.cs

using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using Trivale.Cards;

namespace Trivale.Game;

public class Player
{
    public bool IsHuman { get; set; }
    public string AIType { get; set; } = "simple";
    public List<Card> Hand { get; set; } = new();
    public int Score { get; set; } = 0;
    public int RequiredTricks { get; set; } = -1; // -1 means no requirement
}

public enum EncounterType
{
    SecuredSystem,  // Dealt hand only
    Backdoor,       // Choose hand
    Firewall       // See and modify hand
}

public partial class GameState : Node
{
    // Core state
    private List<Player> _players = new();
    private List<Card> _cardsOnTable = new();
    private int _currentPlayer = 0;
    private Suit _leadSuit = Suit.None;
    private Suit _trumpSuit = Suit.None;
    
    // Game configuration
    public int NumPlayers { get; private set; } = 4;
    public int HandSize { get; private set; } = 5;
    public EncounterType CurrentEncounter { get; private set; } = EncounterType.SecuredSystem;
    
    // Game status
    public bool IsGameOver { get; private set; } = false;
    public int Winner { get; private set; } = -1;
    public string StatusMessage { get; private set; } = "";
    
    // Signals
    [Signal]
    public delegate void GameStateChangedEventHandler();
    
    [Signal]
    public delegate void TrickCompletedEventHandler(int winner);
    
    [Signal]
    public delegate void GameOverEventHandler(int winner);
    
    public override void _Ready()
    {
        InitializeGame();
    }
    
    public void InitializeGame(EncounterType encounterType = EncounterType.SecuredSystem)
    {
        CurrentEncounter = encounterType;
        _players.Clear();
        _cardsOnTable.Clear();
        
        // Initialize players (first player is human)
        _players.Add(new Player { IsHuman = true });
        for (int i = 1; i < NumPlayers; i++)
        {
            _players.Add(new Player { IsHuman = false });
        }
        
        switch (CurrentEncounter)
        {
            case EncounterType.SecuredSystem:
                DealRandomHands();
                break;
            case EncounterType.Backdoor:
                // Will be populated by player choice
                break;
            case EncounterType.Firewall:
                DealRandomHands();
                // Allow modifications later
                break;
        }
        
        EmitSignal(SignalName.GameStateChanged);
    }
    
    private void DealRandomHands()
    {
        var deck = CreateDeck();
        ShuffleDeck(deck);
        
        foreach (var player in _players)
        {
            player.Hand = deck.Take(HandSize).ToList();
            deck.RemoveRange(0, HandSize);
            
            // Set ownership
            foreach (var card in player.Hand)
            {
                card.Owner = _players.IndexOf(player);
            }
        }
    }
    
    public bool PlayCard(int playerIndex, Card card)
    {
        var player = _players[playerIndex];
        
        if (!IsValidPlay(playerIndex, card))
            return false;
            
        player.Hand.Remove(card);
        _cardsOnTable.Add(card);
        
        if (_leadSuit == Suit.None)
            _leadSuit = card.Suit;
        
        // Check if trick is complete
        if (_cardsOnTable.Count == NumPlayers)
        {
            ResolveTrick();
        }
        else
        {
            _currentPlayer = (_currentPlayer + 1) % NumPlayers;
        }
        
        EmitSignal(SignalName.GameStateChanged);
        return true;
    }
    
    private bool IsValidPlay(int playerIndex, Card card)
    {
        if (playerIndex != _currentPlayer)
            return false;
            
        var player = _players[playerIndex];
        if (!player.Hand.Contains(card))
            return false;
            
        // If there's a lead suit, must follow if possible
        if (_leadSuit != Suit.None && card.Suit != _leadSuit)
        {
            if (player.Hand.Any(c => c.Suit == _leadSuit))
                return false;
        }
        
        return true;
    }
    
    private void ResolveTrick()
    {
        int winnerOffset = 0;
        var winningCard = _cardsOnTable[0];
        
        // Find winning card
        for (int i = 1; i < _cardsOnTable.Count; i++)
        {
            if (Card.CompareCards(_cardsOnTable[i], winningCard, _trumpSuit) > 0)
            {
                winningCard = _cardsOnTable[i];
                winnerOffset = i;
            }
        }
        
        int winner = (_currentPlayer + winnerOffset) % NumPlayers;
        _players[winner].Score++;
        
        EmitSignal(SignalName.TrickCompleted, winner);
        
        // Check if game is over
        if (_players.All(p => p.Hand.Count == 0))
        {
            CheckGameOver();
        }
        else
        {
            // Set up next trick
            _cardsOnTable.Clear();
            _leadSuit = Suit.None;
            _currentPlayer = winner;
        }
        
        EmitSignal(SignalName.GameStateChanged);
    }
    
    private void CheckGameOver()
    {
        // Handle different win conditions based on encounter type
        switch (CurrentEncounter)
        {
            case EncounterType.SecuredSystem:
                // Basic win condition - most tricks
                Winner = GetPlayerWithHighestScore();
                break;
                
            default:
                // Other encounter types might have special win conditions
                Winner = GetPlayerWithHighestScore();
                break;
        }
        
        IsGameOver = true;
        EmitSignal(SignalName.GameOver, Winner);
    }
    
    private int GetPlayerWithHighestScore()
    {
        int maxScore = _players.Max(p => p.Score);
        return _players.FindIndex(p => p.Score == maxScore);
    }
    
    // Helper methods
    private List<Card> CreateDeck()
    {
        var deck = new List<Card>();
        foreach (Suit suit in Enum.GetValues(typeof(Suit)))
        {
            if (suit == Suit.None || suit == Suit.NoTrump) continue;
            
            foreach (Value value in Enum.GetValues(typeof(Value)))
            {
                deck.Add(new Card { Suit = suit, Value = value });
            }
        }
        return deck;
    }
    
    private void ShuffleDeck(List<Card> deck)
    {
        var rng = new Random();
        int n = deck.Count;
        while (n > 1)
        {
            n--;
            int k = rng.Next(n + 1);
            var temp = deck[k];
            deck[k] = deck[n];
            deck[n] = temp;
        }
    }
    
    // Public accessors
    public List<Card> GetHand(int playerIndex) => _players[playerIndex].Hand;
    public List<Card> GetTableCards() => new List<Card>(_cardsOnTable);
    public int GetCurrentPlayer() => _currentPlayer;
    public Suit GetLeadSuit() => _leadSuit;
    public Suit GetTrumpSuit() => _trumpSuit;
    public bool IsHumanPlayer(int playerIndex) => _players[playerIndex].IsHuman;
    public int GetScore(int playerIndex) => _players[playerIndex].Score;
    public int GetRequiredTricks(int playerIndex) => _players[playerIndex].RequiredTricks;
}

================
File: src/Terminal/Terminal.cs
================
// src/Terminal/Terminal.cs

using Godot;
using System.Collections.Generic;

namespace Trivale.Terminal;

public partial class Terminal : Control
{
    [Export]
    public string Title { get; set; } = "Terminal";
    
    [Export]
    public Color BorderColor { get; set; } = Colors.Green;
    
    private RichTextLabel _contentLabel;
    private LineEdit _inputLine;
    private Panel _titleBar;
    private Label _titleLabel;
    private ShaderMaterial _crtEffect;
    private List<string> _commandHistory = new();
    private int _historyPosition = -1;
    
    public override void _Ready()
    {
        SetupLayout();
        SetupEffects();
        ConnectSignals();
    }
    
    private void SetupLayout()
    {
        // Create title bar
        _titleBar = new Panel();
        AddChild(_titleBar);
        
        _titleLabel = new Label
        {
            Text = Title,
            HorizontalAlignment = HorizontalAlignment.Left,
            VerticalAlignment = VerticalAlignment.Center
        };
        _titleBar.AddChild(_titleLabel);
        
        // Create content area
        _contentLabel = new RichTextLabel
        {
            BbcodeEnabled = true,
            ScrollFollowing = true
        };
        AddChild(_contentLabel);
        
        // Create input line
        _inputLine = new LineEdit();
        AddChild(_inputLine);
    }
    
    private void SetupEffects()
    {
        _crtEffect = new ShaderMaterial();
        // TODO: Load and configure CRT shader
    }
    
    private void ConnectSignals()
    {
        _inputLine.TextSubmitted += OnInputSubmitted;
    }
    
    private void OnInputSubmitted(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return;
        
        _commandHistory.Add(text);
        _historyPosition = _commandHistory.Count;
        _inputLine.Clear();
        
        ProcessCommand(text);
    }
    
    private void ProcessCommand(string command)
    {
        // TODO: Implement command processing
        AppendText($"> {command}\n");
    }
    
    public void AppendText(string text)
    {
        _contentLabel.AppendText(text);
    }
    
    public override void _UnhandledInput(InputEvent @event)
    {
        if (@event is InputEventKey keyEvent && keyEvent.Pressed)
        {
            switch (keyEvent.Keycode)
            {
                case Key.Up:
                    NavigateHistory(-1);
                    break;
                case Key.Down:
                    NavigateHistory(1);
                    break;
            }
        }
    }
    
    private void NavigateHistory(int direction)
    {
        if (_commandHistory.Count == 0) return;
        
        _historyPosition = Mathf.Clamp(
            _historyPosition + direction,
            0,
            _commandHistory.Count
        );
        
        if (_historyPosition < _commandHistory.Count)
        {
            _inputLine.Text = _commandHistory[_historyPosition];
            _inputLine.CaretColumn = _inputLine.Text.Length;
        }
        else
        {
            _inputLine.Clear();
        }
    }
}
