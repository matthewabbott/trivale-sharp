Below is a **technical implementation specification** that an LLM agent (or human developer) could follow to:

1. **Remove** or rename any old/complex main menu files you no longer want.  
2. **Add** a new “SimpleMainMenu” scene and its C# script.  
3. **Add** placeholder “CardGame” and “Settings” scenes (plus minimal scripts if needed).  
4. **Implement** a basic “MemSlot” UI representation.  
5. **Wire** everything up so that pressing a button updates the MemSlot display and loads the correct scene into a viewport container.

Use this as a structured guide for an AI (or a developer) to update your Godot 4 C# codebase with minimal confusion. This specification avoids any Godot methods that are not part of the official Godot 4 C# API.

---

# 1. Files to Remove or Rename

You mentioned you currently have a complex main menu system with advanced UI/process management logic. The easiest approach is to remove (or rename) them so they don’t conflict with the new simplified main menu. For example:

1. **Files to Remove (if no longer needed):**  
   - `OldMainMenu.tscn`  
   - `OldMainMenu.cs`  
   - Any other advanced UI or process-related scripts that you want to replace with the simpler version.

2. **Alternatively, Rename Instead of Deleting**  
   - If you need them later, rename them to `LegacyMainMenu.tscn`, `LegacyMainMenu.cs`, etc.  
   - Comment out any references in `ProjectSettings` or other parts of the code that automatically load `OldMainMenu`.

Ensure that any references in your `ProjectSettings` or custom code that loaded the old menu are updated or removed so you can load the new `SimpleMainMenu`.

---

# 2. Files to Add

The following new files will form your basic “Simple Main Menu” system:

1. **Scene File**: `SimpleMainMenu.tscn`  
2. **Script File**: `SimpleMainMenu.cs` (attached to `SimpleMainMenu.tscn`)  
3. **Scene File**: `CardGameScene.tscn` (placeholder)  
4. **Script File**: `CardGameScene.cs` (optional placeholder script attached to the above scene)  
5. **Scene File**: `SettingsScene.tscn` (placeholder)  
6. **Script File**: `SettingsScene.cs` (optional placeholder script attached to the above scene)  
7. **(Optional) MemSlot UI Script**: `MemSlot.cs` — only if you want to separate the MemSlot logic from the main menu script.

These are the minimal files to get the functionality you described. Each file’s role is explained below.

---

# 3. Scene & Script Details

## 3.1. `SimpleMainMenu.tscn`

A simple approach is to create a **Control** (or **CanvasLayer**) as your root node. Inside it, place:

1. A **Label** or **Control** node designated as the “MemSlot” UI (can be a simple Label to start).
2. Two **Button** nodes:
   - “PlayCardGameButton”
   - “SettingsButton”
3. A **Control** or **PanelContainer** with a child **Viewport** (or simply a `Node` placeholder) that will serve as the “Main Viewport Container” for loaded scenes.

A possible node hierarchy (in the Godot Editor) could look like this:

```
SimpleMainMenu (Control)       <-- Root node
├── MemSlotDisplay (Label)     <-- A simple label for the MemSlot
├── PlayCardGameButton (Button)
├── SettingsButton (Button)
└── ViewportContainer (Control)
    └── LoadedSceneViewport (Viewport)  <-- optional, or we can just add scenes directly under "ViewportContainer" if we like
```

### Required Configuration

- **Anchors & Layout**: Set anchors so that everything scales with the window.  
- **Signals**: Connect each button’s “pressed” signal to methods in `SimpleMainMenu.cs`.

Make sure you attach the `SimpleMainMenu.cs` script to the root node (`SimpleMainMenu (Control)`).

---

## 3.2. `SimpleMainMenu.cs`

This script contains the logic for:

1. **Handling Button Presses** (Play, Settings).  
2. **Updating the MemSlot UI** (to say “Empty” or “Loaded: <scene name>”).  
3. **Loading / Clearing Scenes** within the `ViewportContainer` or `LoadedSceneViewport`.

Below is a **minimal** example outline. Modify as needed, but keep the structure so an AI can insert it cleanly.

```csharp
using Godot;
using System;

public partial class SimpleMainMenu : Control
{
    // References to nodes in this scene
    private Label _memSlotDisplay;
    private Button _playCardGameButton;
    private Button _settingsButton;
    private Control _viewportContainer;  // or PanelContainer, etc.

    // Optional: store the path to your placeholder scenes
    private const string CardGameScenePath = "res://CardGameScene.tscn";
    private const string SettingsScenePath = "res://SettingsScene.tscn";

    public override void _Ready()
    {
        // Get references to child nodes
        _memSlotDisplay = GetNode<Label>("MemSlotDisplay");
        _playCardGameButton = GetNode<Button>("PlayCardGameButton");
        _settingsButton = GetNode<Button>("SettingsButton");
        _viewportContainer = GetNode<Control>("ViewportContainer");

        // Connect button signals
        _playCardGameButton.Pressed += OnPlayCardGamePressed;
        _settingsButton.Pressed += OnSettingsPressed;

        // Initially show MEM slot as empty
        UpdateMemSlotUI(true, "");
    }

    private void OnPlayCardGamePressed()
    {
        // Update MemSlot display
        UpdateMemSlotUI(false, "CARD GAME");
        // Load the card game scene
        LoadSceneInViewport(CardGameScenePath);
    }

    private void OnSettingsPressed()
    {
        // Update MemSlot display
        UpdateMemSlotUI(false, "SETTINGS");
        // Load the settings scene
        LoadSceneInViewport(SettingsScenePath);
    }

    private void UpdateMemSlotUI(bool isEmpty, string loadedText)
    {
        if (isEmpty)
        {
            _memSlotDisplay.Text = "└── □ [         ]";
        }
        else
        {
            _memSlotDisplay.Text = $"└── ■ [LOADED: {loadedText}]";
        }
    }

    private void LoadSceneInViewport(string scenePath)
    {
        // Clear previous children from the viewport container
        foreach (Node child in _viewportContainer.GetChildren())
        {
            child.QueueFree();
        }

        // Load and instance the new scene
        var sceneResource = ResourceLoader.Load<PackedScene>(scenePath);
        if (sceneResource == null)
        {
            GD.PrintErr("Failed to load scene: " + scenePath);
            return;
        }

        Node newScene = sceneResource.Instantiate();
        _viewportContainer.AddChild(newScene);
    }
}
```

### Notes / Customization

- The `_Ready()` method obtains references to the Label, Buttons, and the viewport container.  
- Pressing a button calls `UpdateMemSlotUI` (to change the slot’s displayed text) and `LoadSceneInViewport` (to actually load the scene).  
- You can further refine how the MemSlot text is rendered.  
- If you prefer to separate MemSlot logic into its own `MemSlot.cs` script, see Section [3.5](#35-memslotcs-optional).

---

## 3.3. `CardGameScene.tscn` & `CardGameScene.cs` (Placeholder)

Create a simple scene called `CardGameScene.tscn`, add a root node of type **Control** (or any node type you prefer). Attach an optional script `CardGameScene.cs` if you want minimal logic.

**Example**:

```
CardGameScene (Control)
```

Script (`CardGameScene.cs`) might just contain:

```csharp
using Godot;
using System;

public partial class CardGameScene : Control
{
    public override void _Ready()
    {
        GD.Print("CardGameScene loaded.");
    }
}
```

This is just so you can confirm that the “Card Game” scene is indeed loading.

---

## 3.4. `SettingsScene.tscn` & `SettingsScene.cs` (Placeholder)

Similarly, create a scene called `SettingsScene.tscn` with a root **Control** node. Optionally attach a script `SettingsScene.cs`:

```csharp
using Godot;
using System;

public partial class SettingsScene : Control
{
    public override void _Ready()
    {
        GD.Print("SettingsScene loaded.");
    }
}
```

This is just a placeholder; you can replace it with real settings code later.

---

## 3.5. `MemSlot.cs` (Optional)

If you want to keep `SimpleMainMenu.cs` minimal or you anticipate multiple MemSlots in the future, you can isolate the MemSlot’s logic. Then in `SimpleMainMenu.cs`, you simply call something like `memSlot.SetLoaded(true, "SETTINGS")`. **This is optional.** Here’s an example:

```csharp
using Godot;
using System;

public partial class MemSlot : Control
{
    private Label _label;

    public override void _Ready()
    {
        _label = GetNode<Label>("Label"); 
        // 'Label' could be a child node of this MemSlot control
        SetEmpty();
    }

    public void SetEmpty()
    {
        if (_label != null)
            _label.Text = "└── □ [         ]";
    }

    public void SetLoaded(string labelText)
    {
        if (_label != null)
            _label.Text = $"└── ■ [LOADED: {labelText}]";
    }
}
```

Then in your `SimpleMainMenu.tscn`, instead of a `Label` node for the MemSlot, you would have a `MemSlot` node (with `MemSlot.cs` attached). The main menu script would do:

```csharp
private MemSlot _memSlot;

public override void _Ready()
{
    _memSlot = GetNode<MemSlot>("MemSlot");
    ...
}

private void OnPlayCardGamePressed()
{
    _memSlot.SetLoaded("CARD GAME");
    LoadSceneInViewport(CardGameScenePath);
}
```

**But** if you only have one memslot for now, a single label in the main menu script is perfectly fine.

---

# 4. Additional Notes & Best Practices

1. **Scene Paths**: Make sure `res://` paths in `SimpleMainMenu.cs` match the actual location of `CardGameScene.tscn` and `SettingsScene.tscn` in your file structure.  
2. **Control Layout**: In `SimpleMainMenu.tscn`, set anchors/margins so your layout is responsive.  
3. **Testing**: Run the project; you should see the menu screen. Clicking “Play Card Game” should update the MemSlot label and load the CardGameScene in the container. Same for “Settings”.  
4. **Renaming**: If you want to name your UI elements differently in the Editor, remember to adjust the node paths in `GetNode<...>("NodeName")`.  
5. **Future Expansions**:  
   - Add more MEM slots by copying the same logic (or dynamically instancing `MemSlot` nodes).  
   - Move from text-based representation of loaded states to icons or custom controls.  
   - Reintroduce advanced “ProcessManager” logic once the minimal system is stable.

---

# 5. Final Summary for the LLM Agent

1. **Delete or rename old main menu and associated advanced logic** (e.g., `OldMainMenu.tscn`, `OldMainMenu.cs`).  
2. **Create** a new scene `SimpleMainMenu.tscn` (Control root) with:  
   - A `Label` named `MemSlotDisplay` (for the MemSlot text).  
   - Two `Button` nodes named `PlayCardGameButton` and `SettingsButton`.  
   - A `Control` named `ViewportContainer` (for loaded scenes).  
3. **Attach** the new script `SimpleMainMenu.cs` to `SimpleMainMenu.tscn` with the code provided.  
4. **Create** placeholder scenes `CardGameScene.tscn` + `CardGameScene.cs` and `SettingsScene.tscn` + `SettingsScene.cs`.  
5. **Verify** that pressing the buttons changes the MemSlot text and loads the correct scene.  
6. **(Optional)** Implement a separate `MemSlot.cs` if you want a dedicated script for the MemSlot UI node.

With these instructions, an AI (or developer) should be able to modify your project in a straightforward manner, ensuring the new minimal main menu is functional, separated from advanced logic, and ready for future expansion.