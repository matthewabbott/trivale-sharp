# Trivale: A Terminal-Based Cyberpunk Card Game

## Core Concept
A hacker's interface that serves as both the game's menu system and a core gameplay mechanic. Players take on the role of netrunners who perceive cyberspace through the lens of card games, breaking into corporate systems through a series of terminal interfaces and security layers. The interface itself is part of the puzzle - learning to manipulate windows, save states, and combine tools is key to solving increasingly complex challenges.

## Architecture Overview

### Directory Structure
```
src/Game/
  Core/           # Domain models and core interfaces
    Types.cs      # Core game types (GameRules, TrickResult)
    Enums.cs      # Core game enums (EncounterType)
    Interfaces/   # Core game mechanics interfaces
      ITrickTakingGame.cs
      IPlayerManager.cs
  Memory/         # Memory slot management
    Types.cs      # Slot types and states
    Interfaces/   # Memory management interfaces
      IMemorySlot.cs
      IMemoryManager.cs
  Services/       # Management and coordination services
    DeckManager.cs
    GameLifecycleManager.cs
    GameEventCoordinator.cs
    GameStateManager.cs
    AIController.cs
    MemorySlotManager.cs
  Implementation/ # Core interface implementations
    TrickTakingGame.cs
    PlayerManager.cs
    MemorySlot.cs
```

### Component Architecture
The game uses a service-based architecture with clear separation of concerns:

#### Memory Management (Memory/)
Core memory slot management with no external dependencies:
```csharp
public interface IMemorySlot
{
    string Id { get; }
    SlotStatus Status { get; }
    Vector2 Position { get; }
    float MemoryUsage { get; }
    float CpuUsage { get; }
    
    bool CanLoadEncounter(IEncounter encounter);
    void LoadEncounter(IEncounter encounter);
    void UnloadEncounter();
    Dictionary<string, object> GetState();
}

public interface IMemoryManager
{
    int MaxSlots { get; }
    IReadOnlyList<IMemorySlot> Slots { get; }
    float TotalMemory { get; }
    
    bool TryAllocateSlot(IEncounter encounter, out IMemorySlot slot);
    void DeallocateSlot(string slotId);
    IMemorySlot GetSlot(string slotId);
}
```

#### Core Game Logic (Core/)
Pure domain logic and interfaces with no external dependencies:
```csharp
public interface ITrickTakingGame
{
    GameRules Rules { get; }
    bool IsGameOver { get; }
    Suit LeadSuit { get; }
    int CurrentPlayer { get; }
    
    bool IsValidPlay(int playerId, Card card);
    bool PlayCard(int playerId, Card card);
    TrickResult ResolveTrick();
}

public interface IPlayerManager
{
    int PlayerCount { get; }
    List<Card> GetPlayerHand(int playerId);
    int GetPlayerScore(int playerId);
    bool IsHuman(int playerId);
    void DealCards(Dictionary<int, List<Card>> hands);
}
```

#### Service Layer (Services/)
Extended to handle memory slot management:
```csharp
public interface IGameLifecycleManager
{
    ITrickTakingGame Game { get; }
    IPlayerManager PlayerManager { get; }
    IGameStateManager StateManager { get; }
    IAIController AIController { get; }
    IDeckManager DeckManager { get; }
    IGameEventCoordinator EventCoordinator { get; }
    IMemoryManager MemoryManager { get; }
    
    void Initialize(Node signalSource);
    void InitializeGame(EncounterType encounterType, int numPlayers, int handSize, int requiredTricks);
    void Cleanup();
}

public interface IGameEventCoordinator
{
    void Initialize(Node signalSource);
    void EmitGameStateChanged();
    void EmitTrickCompleted(int winner);
    void EmitGameOver(int winner);
    void EmitSlotStateChanged(string slotId);
}
```

#### Facade (GameState)
Enhanced to support memory slot management:
```csharp
public partial class GameState : Node
{
    private readonly IGameLifecycleManager _lifecycleManager;
    private readonly IMemoryManager _memoryManager;
    
    public bool IsGameOver => _lifecycleManager.Game.IsGameOver;
    public int RequiredTricks { get; private set; }
    public int Winner { get; private set; }
    public IReadOnlyList<IMemorySlot> MemorySlots => _memoryManager.Slots;
    
    // Additional signals for memory management
    [Signal] public delegate void SlotStateChangedEventHandler(string slotId);
    [Signal] public delegate void SlotAllocatedEventHandler(string slotId);
    [Signal] public delegate void SlotDeallocatedEventHandler(string slotId);
}
```

### Scene Management System
Modified to work within memory slots:

```csharp
public interface IEncounter
{
    string Id { get; }
    string Type { get; }
    Dictionary<string, float> ResourceRequirements { get; }
    bool IsComplete { get; }
    IMemorySlot Slot { get; }
    
    void Initialize(Dictionary<string, object> initialState);
    void Update(float delta);
    Dictionary<string, object> GetState();
    
    event Action<Dictionary<string, object>> StateChanged;
    event Action<string> EncounterEvent;
}

public class CardGameEncounter : BaseEncounter
{
    private readonly GameState _gameState;
    private readonly GameConfiguration _config;
    private IMemorySlot _slot;
    
    public override string Type => "CardGame";
    public override IMemorySlot Slot => _slot;
    
    public override bool LoadIntoSlot(IMemorySlot slot)
    {
        if (!slot.CanLoadEncounter(this))
            return false;
            
        _slot = slot;
        slot.LoadEncounter(this);
        return true;
    }
}
```

Scene managers handle UI representation within slots:
```csharp
public partial class CardEncounterScene : EncounterScene
{
    private IMemorySlot _slot;
    private CardTerminalWindow _handWindow;
    private CardTerminalWindow _tableWindow;
    private CardTerminalWindow _controlWindow;
    
    public override void Initialize(IMemorySlot slot, IEncounter encounter)
    {
        _slot = slot;
        base.Initialize(encounter);
        
        // Position windows within slot boundaries
        PositionWindows(_slot.Position, _slot.Size);
    }
    
    protected override void OnEncounterStateChanged(Dictionary<string, object> state);
}
```

## System Integration

### Event Flow
1. Core game events (ITrickTakingGame) -> GameEventCoordinator
2. Memory slot events -> GameEventCoordinator
3. GameEventCoordinator -> GameState signals
4. GameState signals -> EncounterScene
5. EncounterScene -> UI updates

### Component Lifecycle
1. GameState creates GameLifecycleManager and MemoryManager
2. MemoryManager initializes available slots
3. GameLifecycleManager initializes game components
4. Components register with GameEventCoordinator
5. GameLifecycleManager manages cleanup

### State Management
1. GameStateManager tracks game state
2. MemoryManager tracks slot states
3. DeckManager handles card operations
4. PlayerManager maintains player state
5. AIController manages AI behavior
6. GameEventCoordinator bridges events to UI

## Best Practices

### Architecture Guidelines
- Keep Core/ free of external dependencies
- Services handle coordination between components
- Use facades to isolate framework integration
- Follow dependency injection patterns
- Maintain clear component boundaries

### Event Handling
- Use GameEventCoordinator for all events
- Keep event flow unidirectional
- Isolate Godot signals to facades
- Handle cleanup properly

### Resource Management
- Track component resources per slot
- Validate slot resource requirements
- Support cross-slot resource sharing
- Clean up resources on slot deallocation

### Testing
- Core logic should be fully testable in isolation
- Mock services for component testing
- Use dependency injection for test configurations
- Validate state transitions

### Future Extensibility
- Design services for easy replacement
- Keep component interfaces stable
- Document extension points
- Plan for cross-encounter features